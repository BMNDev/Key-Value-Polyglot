On paternity leave for my second child, I found myself writing an in-memory key-value store (think memcached), in Go, Python and C. It's an interesting comparison of the languages. Also, I was wondering how hard it would be to replace memcached, if we had specific requirements for our key-value store.

If you write a version (see Spec) in a different language, please send it to me, either directly or as a pull-request on github. I'll add it to the repo.

## Spec

The key-value stores are an in-memory hash map. They do this:

1. Listen on port 11211

2. Accept 'set' and 'get' commands, so that you can reproduce the following telnet interaction:

    telnet 127.0.0.1 11211

    set greeting 0 0 11     # User
    Hello World             # User
    STORED                  # Server response
    get greeting            # User
    VALUE greeting 0 11     # Server response
    Hello World             # Server response
    END                     # Server response

You type the 'set', 'Hello World' and 'get' lines. The rest are replies.
In the 'set' line, the '11' is the length of the value ('Hello World') in bytes. The two zero's are ignored. All lines terminate with \r\n.

The key-value store emulates enough of 'set' and 'get' from the [memcached protocol](http://code.sixapart.com/svn/memcached/trunk/server/doc/protocol.txt) that we can test them with a memcached client.

Script test.py is included, which uses pylibmc. To get pylibmc:
 - sudo pip install pylibmc
 - OR sudo apt-get install python-pylibmc

python test.py

## Build

- Go version:
 You need gorun to run it as a script. (https://wiki.ubuntu.com/gorun).
 Uses Go release-branch r60.

- Python version:
 Uses Python 2.7 (2.6+ ?), just run the script.

- C version:
 Build with: gcc -std=gnu99 -g -W -Wall -pedantic -o memg memg.c

## Writing it

The socket part was easy. Our languages are wrapping POSIX socket system calls. C maps the calls exactly, and Python maps the C calls very closely. Go does a bit more work for us, replacing socket-bind-listen-accept with just listen-accept.

The tricky part is managing the data you get from the socket. Sockets are just streams of data, it's up to the protocol to say when a message starts and ends. For the memcached protocol, we need to be able to read until \r\n, and also read a specific amount of bytes (which might include \r\n).
Go makes that easy, with the bufio package. Python makes it easy too, once you figure out you can turn a socket into a file (via socket.makefile). In C of course, you're on your own.

The C version took the longest to write, because my C was rusty, and I had to implement buffering around the socket 'recv' call.

The Python version took me a while to get right. I knew Python wouldn't make me write my own buffering code, and I spent too long playing with timeout and non-blocking setups. Once I realized I could treat the socket as a file ('makefile') things got easier.

The Go version was the easiest to write because I had already used the bufio package, which solves our stream buffering problem.

## Performance

To time the different versions on your machine, edit test.py replacing 10 with 500 (at least), and run: time python test.py

The C and Python versions perform similarly. The Python version is spending most of it's time in the 'recv' system call, and I presume so is the C version. That neutralizes the speed advantage C should have over Python.

The Go version is many times faster than the C and Python version. I'm not sure why. I suspect it is something to do with 'pollServer' in net/fd.go, which might be filling buffers in the background. Or it could be me doing something dumb in C and Python, and accidentaly not having done it in Go. Please let me know if that's the case.

## Profiling

To make profiling easier, each version accepts a '--single' command line parameter, so that it exits after a single connection.

#### Python

    python -m cProfile -o stats memg.py --single
    $ python
    > import pstats
    > p = pstats.Stats("stats")
    > p.strip_dirs().sort_stats("cumulative").print_stats(20)

#### Go

http://blog.golang.org/2011/06/profiling-go-programs.html

1. Uncomment the labelled lines in the source.

2. We're using 'gorun', but the profilier needs a real executable. First delete the first line (the #!) from memg.go, then compile and link it:
 - On 32bit: 8g memg.go ; 8l -o memg-go memg.8
 - On 64bit: 6g memg.go ; 6l -o memg-go memg.6

3. Run it with '--single' so that it exits after the test connection closes: ./memg.go --single.
Then run test.py ; because this version is so fast and this profiler samples at a fixed rate, you'll probably need to change test.py to to 10000 iterations.

4. Finally, run the goprof tool on your output:

    $ gopprof memg-go memg.prof
    (pprof) top10 --cum

#### C

TODO: How do we profile the C version?
